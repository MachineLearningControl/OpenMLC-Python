from PyQt5.QtCore import Qt, pyqtSignal, QObject
from PyQt5.QtWidgets import QDialog
from PyQt5.QtWidgets import QVBoxLayout
from MLC.GUI.Experiment.QtCharts.QtChartWrapper import QtChartWrapper
from MLC.GUI.Autogenerated.autogenerated import Ui_arduino_performance_test
from MLC.arduino import boards

class ArduinoStatsDialog(QDialog, QObject):
    
    signal_update = pyqtSignal()

    def __init__(self, bench_input, parent=None):
        super(ArduinoStatsDialog, self).__init__(parent)
        super(QObject, self).__init__()
        self.ui = Ui_arduino_performance_test()
        self.ui.setupUi(self)
        self.__stats_layout=QVBoxLayout(self.ui.graph_base)
        self.__iochart = QtChartWrapper(no_spline=True)
        self.__iochart.set_title("Arduino I/O operations")
        self.__iochart.set_xaxis(log=False, label="Seconds",
                                       label_format='%i')
        self.__iochart.set_yaxis(log=False, label="Operations",
                                       label_format='%g')
        self.__iochart.add_data([0], [0], color=Qt.red, line_width=2)
        self._config_defaults()
        self.__stats_layout.addWidget(self.__iochart.get_widget())
        self.__input = bench_input

        self.signal_update.connect(self.handle_update)
        self.__bench_reset_handlers = []
        self.__bench_close_handlers = []

    def _config_defaults(self):
        self.__x_axis_max = 5
        self.__y_axis_max = 200
        self.__iochart.get_widget().chart().axisX().setRange(1, self.__x_axis_max)
        self.__iochart.get_widget().chart().axisY().setRange(0,self.__y_axis_max)

        self.ui.avg_op_value.setText("%.2f" % 0.0)
        self.ui.max_op_value.setText(str(0))
        self.ui.min_op_value.setText(str(0))
        self.ui.std_dev_value.setText("%.2f" % 0.0)

    def connect_to_reset(self, handler):
        self.__bench_reset_handlers.append(handler)

    def connect_to_close(self,handler):
        self.__bench_close_handlers.append(handler)
        

    def update(self):
        self.signal_update.emit()

    def handle_update(self):
        points = self.__input.get_points()

        if len(points["X"]) == 0 or len(points["Y"]) == 0:
           return

        if len(points["X"]) >= self.__x_axis_max:
           self.__x_axis_max = len(points["X"]) + 10
           self.__iochart.get_widget().chart().axisX().setRange(1, self.__x_axis_max) 

        if points["Y"][len(points["Y"])-1] >= self.__y_axis_max - 5:
           self.__y_axis_max = points["Y"][len(points["Y"])-1] + 10
           self.__iochart.get_widget().chart().axisY().setRange(1, self.__y_axis_max) 
        
        self.__iochart.append_point(0, len(points["Y"]) + 1, points["Y"][len(points["Y"])-1]) 

        self.ui.avg_op_value.setText("%.2f" % self.__input.get_avg())
        self.ui.max_op_value.setText(str(self.__input.get_max()))
        self.ui.min_op_value.setText(str(self.__input.get_min()))
        self.ui.std_dev_value.setText("%.2f" % self.__input.std_deviation())

    def on_bench_reset(self):
        for i in self.__bench_reset_handlers:
           i.reset()
        
        self.__iochart.remove_all_curves() 
        self.__iochart.add_data([0], [0], color=Qt.red, line_width=2)
        self._config_defaults()

    def on_close(self):
        for i in self.__bench_close_handlers:
            i.stop()

        self.done(0)

        
        

