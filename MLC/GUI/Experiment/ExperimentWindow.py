# -*- coding: utf-8 -*-
# MLC (Machine Learning Control): A genetic algorithm library to solve chaotic problems
# Copyright (C) 2015-2017, Thomas Duriez (thomas.duriez@gmail.com)
# Copyright (C) 2015, Adrian Durán (adrianmdu@gmail.com)
# Copyright (C) 2015-2017, Ezequiel Torres Feyuk (ezequiel.torresfeyuk@gmail.com)
# Copyright (C) 2016-2017, Marco Germano Zbrun (marco.germano@intraway.com)
# Copyright (C) 2016-2017, Raúl Lopez Skuba (raulopez0@gmail.com)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# -*- coding: utf-8 -*-

import os
import numpy as np
import shutil
import sys
import time

from MLC.Log.log import get_gui_logger
from MLC.GUI.Common.util import test_individual_value
from MLC.GUI.Common.util import check_if_indiv_pass_preevaluation
from MLC.GUI.Autogenerated.autogenerated import Ui_ExperimentWindow
from MLC.GUI.Experiment.ArduinoConfigManager.ArduinoBoardManager import ArduinoBoardManager
from MLC.GUI.Experiment.ChartConfiguration import ChartConfiguration
from MLC.GUI.Experiment.ExperimentInProgress import ExperimentInProgress
from MLC.GUI.Experiment.FirstIndividualsManager import FirstIndividualsManager
from MLC.GUI.Experiment.GenealogyWindow import GenealogyWindow
from MLC.GUI.Experiment.MatplotlibCanvas.CostPerIndividualCanvas import CostPerIndividualCanvas
from MLC.GUI.Experiment.QtCharts.QtChartWrapper import QtChartWrapper
from MLC.GUI.Tables.ConfigDictTableModel import ConfigDictTableModel
from MLC.GUI.Tables.ConfigTableModel import ConfigTableModel
from MLC.individual.Individual import Individual
from MLC.mlc_parameters.mlc_parameters import Config
from MLC.Population.Evaluation.EvaluatorFactory import EvaluatorFactory
from MLC.Population.Population import Population
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtCore import QFileSystemWatcher
from PyQt5.QtCore import Qt
from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QDesktopServices
from PyQt5.QtWidgets import QAbstractItemView
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtWidgets import QInputDialog

from MLC.arduino.protocol import ProtocolConfig, ProtocolSetupException, ProtocolIOException
from MLC.arduino.protocol import ArduinoInterfaceSingleton
from MLC.arduino.connection.base import invalid_connection_builder
from MLC.arduino.connection.serialconnection import ConnectionException, serial_connection_builder
from MLC.arduino.connection.base import BaseConnection

logger = get_gui_logger()


class ExperimentWindow(QMainWindow):
    experiment_finished = pyqtSignal([bool, bool])

    MAX_GENERATIONS = 30

    def __init__(self, mlc_local,
                 experiment_name,
                 experiment_closed_signal,
                 parent=None):
        QMainWindow.__init__(self, parent)
        self._autogenerated_object = Ui_ExperimentWindow()
        self._autogenerated_object.setupUi(self)

        # Open the experiment
        self._mlc_local = mlc_local
        self._experiment_name = experiment_name
        self.setWindowTitle("Experiment {0}".format(self._experiment_name))

        # Experiment tab parameters
        self._mlc_local.open_experiment(self._experiment_name)
        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        self._current_gen = int(experiment_info["generations"])

        self._load_experiment_config()
        self._update_individuals_per_generation_list()
        self._update_experiment_info()
        self._update_individuals_figure()

        # Disable save_config_button until some change is made
        self._autogenerated_object.save_config_button.setDisabled(True)

        # Connect the function that updates the graphics of the Window when the
        # experiment evaluation finished
        self.experiment_finished.connect(self._update_experiment)

        # Signal to be emitted when the experiment is closed
        self._experiment_closed_signal = experiment_closed_signal

        # Watch changes in the experiment config file
        self._file_watcher = QFileSystemWatcher()
        conf_path_list = [self._mlc_local.get_working_dir(),
                          self._experiment_name,
                          self._experiment_name + ".conf"]
        # Use the splat operator to dearrange the list
        self._experiment_conf_path = os.path.join(*conf_path_list)
        self._file_watcher.addPath(self._experiment_conf_path)
        self._file_watcher.fileChanged.connect(self._reload_experiment_config)

        # Experiment in progress chart configuration
        self._chart_conf = ChartConfiguration(self._autogenerated_object)
        indivs_per_gen = Config.get_instance().getint("POPULATION", "size")
        self._chart_conf.init(indivs_per_gen)
        self._update_scatter_chart()

        # Manager of the first individuals
        self._first_indivs_manager = FirstIndividualsManager(parent=self,
                                                             experiment_name=self._experiment_name,
                                                             autogenerated_object=self._autogenerated_object,
                                                             mlc_local=self._mlc_local)

        # Arduino board configurations
        self._board_config, self._serial_conn = mlc_local.get_board_configuration(self._experiment_name)
        ArduinoInterfaceSingleton.set_connection_builder(serial_connection_builder)

        # Update the arduino board group for the first case

        if self._autogenerated_object.disable_board_check.checkState() == Qt.Checked:
            self.on_disable_arduino_toggle(True)

    def closeEvent(self, event):
        logger.debug('[EXPERIMENT {0}] [CLOSE_DIALOG] - Executing overriden closeEvent function'
                     .format(self._experiment_name))
        self._ask_if_experiment_config_must_be_saved()
        # Close the experiment
        self._file_watcher.removePath(self._experiment_conf_path)
        self._mlc_local.close_experiment(self._experiment_name)
        self._experiment_closed_signal.emit(self._experiment_name)

    def on_start_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [START_BUTTON] - Executing on_start_button_clicked function'
                     .format(self._experiment_name))

        try:
            ArduinoInterfaceSingleton.get_instance(protocol_config=self._board_config,
                                                   conn_setup=self._serial_conn)

        except (ProtocolSetupException, ConnectionException) as err:
            logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG] - '
                         'Serial port could not be initialized. Error Msg: {1}'
                         .format(self._experiment_name, err))
            selection = QMessageBox.warning(self, "Connection failure",
                                             "The current connection arduino setup failed during initialization "
                                             "(Error: {0}), this may generate an error in your experiment.\n"
                                             "Do you want to continue?".format(err),
                                             QMessageBox.Yes | QMessageBox.No,
                                             QMessageBox.Yes)
            if selection == QMessageBox.No:
                logger.debug('[EXPERIMENT {0}] [START_BUTTON] - Experiment cancelled by user before start'.format(
                    self._experiment_name))
                QMessageBox.information(self, "Check setup", "Please, open the arduino board configurator in order to "
                                                             "analize and resolve the error.", QMessageBox.Ok)
                return
        except Exception as err:
            self._report_arduino_unhandled_error(err)
            return

        from_gen = int(self._autogenerated_object.from_gen_combo.currentText())
        to_gen = int(self._autogenerated_object.to_gen_combo.currentText())
        number_of_gens = self._mlc_local.get_experiment_info(self._experiment_name)["generations"]

        gen_creator = None
        if number_of_gens == 0:
            from_gen = 0
            # Hide the first individuals tab
            self._autogenerated_object.tabWidget.setTabEnabled(3, False)
            gen_creator = self._first_indivs_manager.get_gen_creator()

        # Check if the experiment range is ok
        if to_gen <= from_gen:
            logger.info("[EXPERIMENT {0}] [START_BUTTON] - Experiment can not be executed. "
                        "'From Generation' index must be greater than 'To Generation' index "
                        "From Gen: {1} - To Gen:{2}"
                        .format(self._experiment_name, from_gen, to_gen))

            QMessageBox.critical(self,
                                 "Invalid Generation Range",
                                 "Experiment can not be executed. 'From Generation' index "
                                 "must be greater than 'To Generation' index")
            return

        if from_gen != number_of_gens:
            # Check if the from generation value is not the last generation. If that's the case, show a warning
            # informing the user that generations will be lost if the experiment continues
            ret = QMessageBox.warning(self,
                                      "Generation To Be Lost Warning",
                                      "'From Generation' index is not the last generation. "
                                      "Generations will be lost if you continue the experiment. "
                                      "Do you want to continue?",
                                      QMessageBox.No | QMessageBox.Yes,
                                      QMessageBox.No)

            if ret == QMessageBox.No:
                return

        logger.info('[EXPERIMENT {0}] [START_BUTTON] - Proceed to execute experiment from Generation '
                    'N°{1} to Generation N°{2}'.format(self._experiment_name, from_gen, to_gen))

        progress_dialog = ExperimentInProgress(mlc_local=self._mlc_local,
                                               parent=self,
                                               experiment_name=self._experiment_name,
                                               to_gen=to_gen,
                                               from_gen=from_gen,
                                               chart_params=self._chart_conf.chart_params(),
                                               parent_signal=self.experiment_finished,
                                               gen_creator=gen_creator)

        progress_dialog.start()

    def on_prev_gen_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [PREV_GEN_BUTTON] - Executing on_prev_gen_button_clicked function'.format(self._experiment_name))
        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        number_of_gens = experiment_info["generations"]

        if self._current_gen > 1:
            self._current_gen -= 1
            self._update_experiment_info()
            self._update_individuals_figure()
            self._update_scatter_chart()

    def on_next_gen_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [NEXT_GEN_BUTTON] - Executing on_next_gen_button_clicked function'.format(self._experiment_name))
        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        number_of_gens = experiment_info["generations"]

        if self._current_gen < number_of_gens:
            self._current_gen += 1
            self._update_experiment_info()
            self._update_individuals_figure()
            self._update_scatter_chart()

    def on_test_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [TEST_BUTTON] - Executing on_test_button_clicked function'
                     .format(self._experiment_name))

        test_indiv_edit = self._autogenerated_object.test_indiv_edit
        if test_indiv_edit.text() == "":
            logger.warn('[EXPERIMENT {0}] [TEST_BUTTON] - The individual value cannot be an empty string'
                        .format(self._experiment_name))
            QMessageBox.information(self, "Test Evaluation Script",
                                    "The individual value cannot be an empty string.", QMessageBox.Ok)
            return

        cost = test_individual_value(parent=self,
                                     experiment_name=self._experiment_name,
                                     log_prefix="[EXPERIMENT_WINDOW]",
                                     indiv_value=test_indiv_edit.text(),
                                     config=Config.get_instance())

        if cost != None:
            test_label_result = self._autogenerated_object.test_label_result
            test_label_result.setText(str(cost))

    def on_test_preev_indiv_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [TEST_BUTTON] - Executing on_test_button_clicked function'
                     .format(self._experiment_name))

        test_indiv_edit = self._autogenerated_object.test_preev_indiv_edit
        if test_indiv_edit.text() == "":
            logger.warn('[EXPERIMENT {0}] [TEST_BUTTON] - The individual value cannot be an empty string'
                        .format(self._experiment_name))
            QMessageBox.information(self, "Test Preevaluation Script",
                                    "The individual value cannot be an empty string.", QMessageBox.Ok)
            return

        result = check_if_indiv_pass_preevaluation(parent=self,
                                                   experiment_name=self._experiment_name,
                                                   log_prefix="[EXPERIMENT_WINDOW]",
                                                   indiv_value=test_indiv_edit.text(),
                                                   config=Config.get_instance())

        if result is not None:
            test_label_result = self._autogenerated_object.test_preev_indiv_result
            test_label_result.setText(str(result))

    def on_log_check_clicked(self):
        logger.debug('[EXPERIMENT {0}] [LOG_CHECK_CLICKED] - Executing on_log_check_clicked function'
                     .format(self._experiment_name))
        self._update_individuals_figure()

    def on_show_all_check_clicked(self):
        logger.debug('[EXPERIMENT {0}] [SHOW_ALL_CHECK_CLICKED] - Executing on_show_all_check_clicked function'
                     .format(self._experiment_name))
        self._update_individuals_figure()

    def on_dimension_check_clicked(self):
        logger.debug('[EXPERIMENT {0}] [DIMENSION_CHECK_CLICKED] - Executing on_dimension_check_clicked function'
                     .format(self._experiment_name))
        # TODO: Don't know what the 3D graphic option should do yet...

    def on_save_config_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [SAVE_CONFIG_BUTTON_CLICKED] - Executing on_save_config_button_clicked function'
                     .format(self._experiment_name))

        # Remove the config file from the Qt File watcher momentarily
        # to avoid rendering unnecesary warnings
        self._file_watcher.removePath(self._experiment_conf_path)
        self._persist_experiment_config()
        self._file_watcher.addPath(self._experiment_conf_path)

    def on_tab_changed(self, tab_index):
        logger.debug('[EXPERIMENT {0}] [TAB_CHANGED] - Executing on_tab_changed function'
                     .format(self._experiment_name))
        self._ask_if_experiment_config_must_be_saved()

    def on_import_config_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [IMPORT_CONFIG_BUTTON_CLICKED] - Executing on_import_config_button_clicked function'
                     .format(self._experiment_name))

        # Get the path of the experiment to import
        config_file_path = QFileDialog.getOpenFileName(self, "Import Experiment", ".",
                                                       "Config File (*.conf)")[0]
        if not config_file_path:
            # User clicked 'Cancel' or simply closed the Dialog
            return

        self._file_watcher.removePath(self._experiment_conf_path)
        self._mlc_local.set_experiment_configuration_from_file(self._experiment_name,
                                                               config_file_path)
        self._load_experiment_config()
        QMessageBox.information(self, "Config File Imported",
                                "New config file {0} was succesfully imported".format(config_file_path))
        logger.info("[EXPERIMENT {0}] [EXPORT_CONFIG] - New config file {1} was "
                    "succesfully imported.".format(self._experiment_name, config_file_path))
        self._autogenerated_object.save_config_button.setDisabled(True)
        self._file_watcher.addPath(self._experiment_conf_path)

    def on_export_config_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [EXPORT_CONFIG_BUTTON_CLICKED] - Executing on_export_config_button_clicked function'
                     .format(self._experiment_name))

        export_dir = QFileDialog.getExistingDirectory(self, 'Choose the directory where to export the configuration file',
                                                      '.', QFileDialog.ShowDirsOnly)
        if not export_dir:
            # User clicked 'Cancel' or simply closed the Dialog
            return

        export_file_name = os.path.join(export_dir, self._experiment_name + ".conf")
        try:
            shutil.copyfile(self._experiment_conf_path, export_file_name)
        except Exception, err:
            QMessageBox.critical(self, "Config File Not Exported",
                                 "Config File could not be exported. "
                                 "Error {0}".format(err))
            logger.error("[EXPERIMENT {0}] [EXPORT_CONFIG] - Config file could not "
                         "be exported. Error: {0}".format(err))
            return

        logger.info("[EXPERIMENT {0}] [EXPORT_CONFIG] - Config file was "
                    "succesfully exported. Location: {1}"
                    .format(self._experiment_name, export_file_name))
        QMessageBox.information(self, "Config File Exported",
                                "Config File was succesfully exported. You can find it at {0}"
                                .format(export_file_name))

    def on_ev_edit_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [EV_EDIT_BUTTON_CLICKED] - Executing on_ev_edit_button_clicked function'
                     .format(self._experiment_name))

        ev_function = self._experiment_config["EVALUATOR"]["evaluation_function"] + ".py"
        ev_path_list = [self._mlc_local.get_working_dir(), self._experiment_name, "Evaluation", ev_function]
        # Use the splat operator to dearrange the list
        ev_path = os.path.join(*ev_path_list)

        if os.path.isfile(ev_path):
            logger.debug('[EXPERIMENT {0}] [EV_EDIT_BUTTON_CLICKED] - Proceed to open file: {0}'
                         .format(ev_path))
            # Check if file exists
            QDesktopServices.openUrl(QUrl(ev_path))
        else:
            QMessageBox.critical(self, "Edit Evaluation Script",
                                 "Evaluation file doesn't exists. Check that file {0} exists"
                                 .format(ev_path, ev_path),
                                 QMessageBox.Ok)

    def on_preev_edit_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [PREEV_EDIT_BUTTON_CLICKED] - Executing on_preev_edit_button_clicked function'
                     .format(self._experiment_name))

        preev_activated = self._experiment_config["EVALUATOR"]["preevaluation"]
        if preev_activated.lower() != "true" and preev_activated != "1":
            QMessageBox.information(self, "Edit Preevaluation Script", "Preevaluation is not activated. "
                                    "Activate it in order to edit the preevaluation function",
                                    QMessageBox.Ok)
            return

        preev_function = self._experiment_config["EVALUATOR"]["preev_function"] + ".py"
        preev_path_list = [self._mlc_local.get_working_dir(), self._experiment_name, "Preevaluation", preev_function]
        # Use the splat operator to dearrange the list
        preev_path = os.path.join(*preev_path_list)

        if os.path.isfile(preev_path):
            logger.debug('[EXPERIMENT {0}] [PREEV_EDIT_BUTTON_CLICKED] - Proceed to open file: {0}'
                         .format(preev_path))
            # Check if file exists
            QDesktopServices.openUrl(QUrl(preev_path))
        else:
            QMessageBox.critical(self, "Edit Preevaluation Script",
                                 "Preevaluation file doesn't exists. Check that file {0} exists"
                                 .format(preev_path),
                                 QMessageBox.Ok)

    def on_gen_count_combo_changed(self, generation):
        logger.debug('[EXPERIMENT {0}] [GEN_COUNT_COMBO_CHANGED] - Executing on_gen_count_combo_changed function'
                     .format(self._experiment_name))
        if self._current_gen == int(generation):
            return

        self._current_gen = int(generation)
        self._update_experiment_info()
        self._update_individuals_figure()
        self._update_scatter_chart()

    def on_chart_config_changed(self, value_changed):
        logger.debug('[EXPERIMENT {0}] [CHART_CONFIG_CHANGED] - Executing on_chart_config_changed function'
                     .format(self._experiment_name))
        self._update_scatter_chart()

    def on_best_indiv_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [BEST_INDIV_BUTTON] - Executing on_best_indiv_button_clicked function')
        self._mlc_local.show_best(self._experiment_name, self._current_gen)

    def on_convergence_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [CONVERGENCE_BUTTON] - Executing on_convergence_button_clicked function')

    def on_genealogy_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [GENEALOGY_BUTTON] - Executing on_genealogy_button_clicked function')

        # Ask the user which Individual he would like to have displayed
        indivs_per_gen = Config.get_instance().getint("POPULATION", "size")
        individuals_list = [str(x) for x in xrange(1, indivs_per_gen + 1)]

        indiv = QInputDialog.getItem(self, "Individual Genealogy",
                                     "Select the individual you would like to display",
                                     individuals_list, 0, False)

        if indiv[1] == True:
            dialog = GenealogyWindow(parent=self,
                                     mlc_local=self._mlc_local,
                                     generation=self._current_gen,
                                     individual=int(indiv[0]),
                                     experiment_name=self._experiment_name)
            dialog.show()

    def on_board_config_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG_BUTTON] - '
                     'Executing on_board_config_button_clicked function'
                     .format(self._experiment_name))
        valid_connection = False
        board_config_window = ArduinoBoardManager(protocol_config=self._board_config, serial_config=self._serial_conn,
                                                  close_handler=self._store_board_configuration, parent_win=self)
        board_config_window.start()

    def on_edit_config_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [EDIT_CONFIG_BUTTON] - '
                     'Executing on_edit_config_button_clicked function'
                     .format(self._experiment_name))
        QDesktopServices.openUrl(QUrl(self._experiment_conf_path))

    def on_first_add_indiv_button_clicked(self):
        self._first_indivs_manager.add_individual()

    def on_first_add_indiv_from_textfile_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG_BUTTON] - '
                     'Executing on_first_add_indiv_from_textfile_button_clicked function'
                     .format(self._experiment_name))
        self._first_indivs_manager.add_individuals_from_textfile()

    def on_first_remove_indiv_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG_BUTTON] - '
                     'Executing on_first_remove_indiv_button_clicked function'
                     .format(self._experiment_name))
        self._first_indivs_manager.remove_individual()

    def on_gen_cut_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [GEN_CUT_BUTTON] - '
                     'Executing on_gen_cut_button_clicked function'
                     .format(self._experiment_name))
        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        number_of_gens = experiment_info["generations"]

        amount_of_gen_losts = number_of_gens - self._current_gen + 1
        response = QMessageBox.warning(self, "Cut Generations",
                                       "{0} generations will be lost with this operation. "
                                       "Do you really want to continue?"
                                       .format(amount_of_gen_losts),
                                       QMessageBox.Yes | QMessageBox.No,
                                       QMessageBox.No)

        if response == QMessageBox.Yes:
            logger.info("[GEN_CUT_BUTTON] Proceed to remove {0} generations (From Generation N°{1} onwards)"
                        .format(amount_of_gen_losts, self._current_gen))
            self._mlc_local.remove_generations_from(self._experiment_name,
                                                    self._current_gen)
            last_gen_removed = self._current_gen
            # Recalculate the amount of generations in the project
            experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
            self._current_gen = experiment_info["generations"]
            self._update_individuals_per_generation_list()
            self._update_experiment_info()
            self._update_individuals_figure()
            self._update_scatter_chart()

            QMessageBox.information(self, "Cut Generations",
                                    "{0} Generations were succesfully removed (From N°{1} onwards)"
                                    .format(amount_of_gen_losts, last_gen_removed))

    def on_gen_start_over_button_clicked(self):
        logger.debug('[EXPERIMENT {0}] [GEN_START_OVER_BUTTON] - '
                     'Executing on_gen_start_over_button_clicked function'
                     .format(self._experiment_name))

        response = QMessageBox.warning(self, "Start Over",
                                       "Except for Generation N°{0}, all generations will be removed. "
                                       "Do you really want to continue?"
                                       .format(self._current_gen),
                                       QMessageBox.Yes | QMessageBox.No,
                                       QMessageBox.No)

        if response == QMessageBox.Yes:
            chosen_generation = self._current_gen
            logger.info("[GEN_START_OVER] Removing all the experiment generations "
                        "except for generation N°{0}".format(self._current_gen))

            experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
            number_of_gens = experiment_info["generations"]

            if self._current_gen != number_of_gens:
                self._mlc_local.remove_generations_from(self._experiment_name,
                                                        self._current_gen + 1)

            if self._current_gen != 1:
                self._mlc_local.remove_generations_to(self._experiment_name,
                                                      self._current_gen - 1)

            # Recalculate the amount of generations in the project
            experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
            self._current_gen = experiment_info["generations"]
            self._update_individuals_per_generation_list()
            self._update_experiment_info()
            self._update_individuals_figure()
            self._update_scatter_chart()

            QMessageBox.information(self, "Star Over Generations",
                                    "Experiment was succesfully pruned. Past Generation "
                                    "N°{0} is the only generation of the experiment"
                                    .format(chosen_generation))

    def on_disable_arduino_toggle(self, active):
        logger.debug('[EXPERIMENT {0}] [DISABLE_ARDUINO] - '
                     'Executing on_disable_arduino_toggle function'
                     .format(self._experiment_name))
        self._autogenerated_object.board_config_button.setDisabled(active)

        if active:
            ArduinoInterfaceSingleton.disable_interface()
        else:
            # FIXME In the future, some logic to get the old connection builder must be implemented
            ArduinoInterfaceSingleton.set_connection_builder(serial_connection_builder)


################################### VIEW AND MODEL METHODS #########################################

    def _config_table_edited(self, left, right):
        config_table = self._autogenerated_object.config_table
        table_model = config_table.model()

        # Get section, parameter and value of the parameter modified
        parameter = table_model.get_data(left.row(), 0)
        section = table_model.get_data(left.row(), 1)
        value = table_model.get_data(left.row(), 2)

        # Modify the experiment config in memory, not the one in the project
        self._experiment_config[section][parameter] = value
        logger.debug('[EXPERIMENT {0}] [CONFIG TABLE] - Parameter ({1}, {2}) edited. New Value: {3}'
                     .format(self._experiment_name, section, parameter, value))
        self._autogenerated_object.save_config_button.setDisabled(False)

    def _update_scatter_chart(self):
        indivs_per_gen = Config.get_instance().getint("POPULATION", "size")
        costs = None
        if self._current_gen != 0:
            generation = self._mlc_local.get_generation(self._experiment_name,
                                                        self._current_gen)
            costs = generation.get_costs()

        self._chart_conf.update_chart(indivs_per_gen, costs)

    def _get_db_view_stored_value(self, model_index, table_model, indiv_id):
        indiv_data = self._mlc_local.get_individual(self._experiment_name, indiv_id)
        old_value = None

        if model_index.column() == 4:
            # Cost modified
            old_value = indiv_data.get_cost_history()[self._current_gen][0][0]
        elif model_index.column() == 5:
            # Value modified
            old_value = indiv_data.get_value()
        return old_value

    def _db_view_edited(self, left, right):
        db_view = self._autogenerated_object.db_view
        table_model = db_view.model()

        response = QMessageBox.information(self, "Editing Experiment DB",
                                           "Do you really want to change value?",
                                           QMessageBox.No | QMessageBox.Yes,
                                           QMessageBox.No)

        indiv_id = int(table_model.get_data(left.row(), 1))
        if response == QMessageBox.No:
            # Get the value stored in the database
            old_value = self._get_db_view_stored_value(model_index=left,
                                                       table_model=table_model,
                                                       indiv_id=indiv_id)
            logger.info('[EXPERIMENT {0}] [DB_VIEW_EDITED] - '
                        'Edition was canceled. Cell({1}, {2}) - Old value: {3}'
                        .format(self._experiment_name, left.row(),
                                left.column(), old_value))
            table_model.set_data(left.row(), left.column(), old_value)
        else:
            value = table_model.get_data(left.row(), left.column())

            if left.column() == 4:
                try:
                    float(value)
                except ValueError:
                    logger.info("[EXPERIMENT {0}] [DB_VIEW_EDITED] - "
                                "Cost inserted is not valid. Individual won't be updated)")
                    QMessageBox.critical(self, "Invalid cost",
                                         "Cost inserted is not valid. Individual won't be updated ")
                    old_value = self._get_db_view_stored_value(model_index=left,
                                                               table_model=table_model,
                                                               indiv_id=indiv_id)
                    table_model.set_data(left.row(), left.column(), old_value)
                    return

                logger.info('[EXPERIMENT {0}] [DB_VIEW_EDITED] - '
                            'Updating database. Cell ({1}, {2}) - Value: {3}'
                            .format(self._experiment_name, left.row(),
                                    left.column(), value))
                self._mlc_local.update_individual_cost(experiment_name=self._experiment_name,
                                                       indiv_id=indiv_id,
                                                       new_cost=float(value),
                                                       new_ev_time=time.time(),
                                                       generation=self._current_gen)
                self._update_individuals_figure()
                QMessageBox.information(self, "Experiment updated",
                                        "Individual was succesfully updated")
            elif left.column() == 5:
                # TODO
                pass

    def _update_individuals_per_generation_list(self):
        # Clean up ye olde list
        self._individuals_per_generation = []

        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        number_of_gens = experiment_info["generations"]
        indivs_per_gen = experiment_info["individuals_per_generation"]

        if number_of_gens == 0:
            # Disable Experiment tab buttons
            self._autogenerated_object.left_menu_frame.setDisabled(True)
            self._autogenerated_object.right_menu_frame.setDisabled(True)
            self._autogenerated_object.exp_gen_count_group.setDisabled(True)
            self._autogenerated_object.tabWidget.setTabEnabled(3, True)
            return
        else:
            self._autogenerated_object.left_menu_frame.setDisabled(False)
            self._autogenerated_object.right_menu_frame.setDisabled(False)
            self._autogenerated_object.exp_gen_count_group.setDisabled(False)
            self._autogenerated_object.tabWidget.setTabEnabled(3, False)

        # Complete the list
        individuals = self._mlc_local.get_individuals(self._experiment_name)
        for index in xrange(1, number_of_gens + 1):
            gens_list = []

            generation = self._mlc_local.get_generation(self._experiment_name, index)
            pop_individuals = generation.get_individuals()
            costs = generation.get_costs()
            gen_methods = generation.get_gen_methods()

            for pop_index in xrange(1, indivs_per_gen + 1):
                indiv_index = pop_individuals[pop_index - 1]
                indiv_cost = costs[pop_index - 1]
                indiv_value = individuals[indiv_index].get_value()
                indiv_appearences = individuals[indiv_index].get_appearances()

                indiv_gen_method = Population.gen_method_description(gen_methods[pop_index - 1])
                gens_list.append([pop_index, indiv_index, indiv_gen_method,
                                  indiv_appearences, indiv_cost, indiv_value])

            self._individuals_per_generation.append(gens_list)

    def _load_experiment_config(self):
        header = ['Parameter', 'Section', 'Value']
        editable_columns = [2]

        self._experiment_config = self._mlc_local.get_experiment_configuration(self._experiment_name)
        table_model = ConfigDictTableModel("CONFIG TABLE", self._experiment_config, header, self)

        config_table = self._autogenerated_object.config_table
        config_table.setModel(table_model)
        config_table.resizeColumnsToContents()
        # config_table.setVisible(False)
        config_table.setSortingEnabled(True)
        # config_table.setVisible(True)
        config_table.setEditTriggers(QAbstractItemView.DoubleClicked)
        table_model.set_editable_columns(editable_columns)
        table_model.set_data_changed_callback(self._config_table_edited)
        table_model.sort_by_col(1)

    def _update_experiment_info(self):
        # Fill the comboboxes
        experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
        from_gen_combo = self._autogenerated_object.from_gen_combo
        to_gen_combo = self._autogenerated_object.to_gen_combo
        gen_count_combo = self._autogenerated_object.gen_count_combo
        exp_gen_count_combo = self._autogenerated_object.exp_gen_count_combo

        from_gen_combo.clear()
        to_gen_combo.clear()
        gen_count_combo.clear()
        exp_gen_count_combo.clear()

        number_of_gens = experiment_info["generations"]
        if number_of_gens == 0:
            from_gen_combo.addItems([str(1)])
            to_gen_combo.addItems([str(x) for x in xrange(2, ExperimentWindow.MAX_GENERATIONS + 1)])
        else:
            from_gen_combo.addItems([str(x) for x in xrange(1, number_of_gens + 1)])
            to_gen_combo.addItems([str(x) for x in xrange(2, ExperimentWindow.MAX_GENERATIONS + 1)])

            # Set the from gen combo to the last generation evaluated
            index = from_gen_combo.findText(str(number_of_gens), Qt.MatchFixedString)
            from_gen_combo.setCurrentIndex(index)

            # set the to_gen_combo to the lest generation evaluated + 1
            to_gen_index = number_of_gens + 1
            if number_of_gens == ExperimentWindow.MAX_GENERATIONS:
                to_gen_index = ExperimentWindow.MAX_GENERATIONS

            index = to_gen_combo.findText(str(to_gen_index), Qt.MatchFixedString)
            to_gen_combo.setCurrentIndex(index)

        # Fill the db_view
        gen_count_group = self._autogenerated_object.gen_count_group
        exp_gen_count_group = self._autogenerated_object.exp_gen_count_group
        if number_of_gens != 0:
            if self._current_gen == 0:
                self._current_gen = 1

            header = ['Population Index', 'Individual Index', 'Gen Method', 'Appearences', 'Cost', 'Value']
            # TODO: Add support for value edition
            # editable_columns = [4, 5]
            editable_columns = [4]

            table_model = ConfigTableModel("DB TABLE", self._individuals_per_generation[self._current_gen - 1],
                                           header, self)
            db_view = self._autogenerated_object.db_view
            db_view.setModel(table_model)
            db_view.resizeColumnsToContents()
            db_view.resizeColumnsToContents()
            db_view.setSortingEnabled(True)
            table_model.set_editable_columns(editable_columns)
            table_model.set_data_changed_callback(self._db_view_edited)
            table_model.sort_by_col(0)

            # Refresh the gen_count_label
            gen_count_group.setTitle("Generation: {0}/{1}".format(self._current_gen, number_of_gens))
            exp_gen_count_group.setTitle("Generation: {0}/{1}".format(self._current_gen, number_of_gens))

            # Refresh the gen_count_combo
            gen_count_combo.addItems(str(x) for x in xrange(1, number_of_gens + 1))
            gen_count_combo.setCurrentIndex(self._current_gen - 1)
            exp_gen_count_combo.addItems(str(x) for x in xrange(1, number_of_gens + 1))
            exp_gen_count_combo.setCurrentIndex(self._current_gen - 1)
        else:
            self._current_gen = 0
            gen_count_group.setTitle("Generation: 0/0")
            db_view = self._autogenerated_object.db_view
            db_view.setModel(None)

    def _update_individuals_figure(self):
        chart_layout = self._autogenerated_object.chart_layout
        if self._current_gen != 0:

            # Draw current generation
            current_generation = self._mlc_local.get_generation(self._experiment_name, self._current_gen)
            costs = current_generation.get_costs()
            samples = np.linspace(1, len(costs), len(costs), dtype=int)
            indiv_chart = QtChartWrapper()
            indiv_chart.set_title('Cost Per Individual')
            ylog = self._autogenerated_object.log_check.isChecked()
            indiv_chart.set_xaxis(log=False, label="Individuals",
                                  label_format='%i', tick_count=10)
            indiv_chart.set_yaxis(log=ylog, label="Costs",
                                  label_format='%g', tick_count=10)
            indiv_chart.add_data(samples, costs, color=Qt.red, line_width=2)

            # Draw all generations only if the show_all button is selected
            if self._autogenerated_object.show_all_check.isChecked():
                experiment_info = self._mlc_local.get_experiment_info(self._experiment_name)
                number_of_gens = experiment_info["generations"]

                for index in xrange(1, number_of_gens + 1):
                    if index == self._current_gen:
                        continue
                    gen = self._mlc_local.get_generation(self._experiment_name, index)
                    costs = gen.get_costs()
                    indiv_chart.add_data(samples, costs, color=Qt.blue, line_width=1)

            # Remove all previous widgets before rendering again
            for i in reversed(range(chart_layout.count())):
                chart_layout.itemAt(i).widget().setParent(None)

            # Add the Indiv Canvas
            indiv_canvas = indiv_chart.get_widget()
            chart_layout.addWidget(indiv_canvas)
        else:
            # Remove all previous widgets before rendering again
            for i in reversed(range(chart_layout.count())):
                chart_layout.itemAt(i).widget().setParent(None)
            chart_layout.addWidget(self._autogenerated_object.textEdit_2)

    def _reload_experiment_config(self, some_string):
        logger.debug('[EXPERIMENT {0}] [EXPERIMENT_CONF_FILE_CHANGED] - '
                     'Executing _experiment_conf_file_changed function'
                     .format(self._experiment_name))

        self._mlc_local.reload_experiment_configuration(self._experiment_name)
        self._load_experiment_config()

        QMessageBox.warning(self, "Experiment Config Changed", "The Experiment config file "
                                  "has changed. The configuration will be reloaded. "
                                  "The changes made will be discarded")
        logger.info('[EXPERIMENT {0}] [RELOAD_CONFIG] - Config file has changed. Configuration will be reloaded')
        self._autogenerated_object.save_config_button.setDisabled(True)
        # FIXME: Dunno why?, but I have to add the config file to the
        # watcher in order to work again the next time
        self._file_watcher.addPath(self._experiment_conf_path)

    def _persist_experiment_config(self):
        try:
            self._mlc_local.set_experiment_configuration(self._experiment_name, self._experiment_config)
        except:
            exc_type, value, traceback = sys.exc_info()
            logger.error('[EXPERIMENT {0}] [PERSIST_CONFIG] - Error while persisting experiment config file. '
                         'Type: {0} - Value: {1} - Traceback: {2}'
                         .format(self._experiment_name, exc_type, value, traceback))
            return
        self._autogenerated_object.save_config_button.setDisabled(True)

    def _ask_if_experiment_config_must_be_saved(self):
        """
        First, ask if the experiment need to be saved. If not, retrieve the
        previous configuration
        """
        if self._autogenerated_object.save_config_button.isEnabled():
            response = QMessageBox.question(self, "Save Experiment Config",
                                            "Experiment config has changed. Do you want to persist the changes made?",
                                            QMessageBox.Yes | QMessageBox.No,
                                            QMessageBox.Yes)
            if response == QMessageBox.Yes:
                self._file_watcher.removePath(self._experiment_conf_path)
                self._persist_experiment_config()
                self._file_watcher.addPath(self._experiment_conf_path)
            else:
                self._load_experiment_config()

            self._autogenerated_object.save_config_button.setDisabled(True)

    def _update_experiment(self, cancelled, failed):
        if not cancelled and not failed:
            QMessageBox.information(self, 'Experiment {0}'.format(self._experiment_name),
                                    'Experiment was succesfully executed.', QMessageBox.Ok)
        if cancelled and not failed:
            QMessageBox.information(self, 'Experiment {0}'.format(self._experiment_name),
                                    'Experiment was cancelled by the user.', QMessageBox.Ok)

        number_of_gens = self._mlc_local.get_experiment_info(self._experiment_name)["generations"]
        self._current_gen = number_of_gens
        self._update_individuals_per_generation_list()
        self._update_experiment_info()
        self._update_individuals_figure()
        self._update_scatter_chart()

    def _store_board_configuration(self, board_config, serial_conn):
        # Pass the parameter as a list to mock PyQt fixed data types
        logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG] - '
                     'Board has been configured'
                     .format(self._experiment_name))

        self._board_config = board_config[0]
        self._serial_conn = serial_conn[0]

        # Init the arduino singleton
        try:
            ArduinoInterfaceSingleton.get_instance(protocol_config=self._board_config,
                                                   conn_setup=self._serial_conn)

            # Update board configuration in the DB
            self._mlc_local.save_board_configuration(self._experiment_name, self._board_config, self._serial_conn)

        except (ProtocolSetupException, ConnectionException) as err:
            logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG] - '
                         'Serial port could not be initialized. Error Msg: {1}'
                         .format(self._experiment_name, err))
            selection = QMessageBox.warning(self, "Connection failure",
                                             "The current connection setup failed during initialization. "
                                             "Do you want to change this configuration? "
                                             "(Choosing \"no\" means that the board will not be usable in the experiment)",
                                             QMessageBox.Yes | QMessageBox.No,
                                             QMessageBox.Yes)
            if selection == QMessageBox.Yes:
                self.on_board_config_button_clicked()
            else:
                self._board_config = self._board_config._replace(connection=BaseConnection())
                self._mlc_local.save_board_configuration(self._experiment_name,
                                                         self._board_config,
                                                         self._serial_conn)

        except Exception as err:
            self._report_arduino_unhandled_error(err)
            return

    def _report_arduino_unhandled_error(self, error):
        logger.debug('[EXPERIMENT {0}] [BOARD_CONFIG] - '
                     'Unhandled error. Error Msg: {1}'
                     .format(self._experiment_name, error))
        QMessageBox.critical(self, "Critical error", "Error: {0}".format(error))
